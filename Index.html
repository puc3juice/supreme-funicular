<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON Path Tracker (Fixed)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin="" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; height: 100vh; overflow: hidden; }
        #map { width: 100%; height: 100vh; }
        .controls { position: absolute; top: 10px; right: 10px; z-index: 1000; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); max-width: 300px; transition: all 0.3s ease; }
        .controls.collapsed { max-width: 60px; }
        .controls-header { padding: 15px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
        .controls.collapsed .controls-header { padding: 10px; justify-content: center; }
        .controls h3 { margin: 0; font-size: 16px; color: #333; }
        .controls.collapsed h3 { display: none; }
        .collapse-toggle { background: none; border: none; font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; color: #666; }
        .controls-content { padding: 0 15px 15px 15px; display: block; }
        .controls.collapsed .controls-content { display: none; }
        .record-button-container { display: none; padding: 10px; }
        .controls.collapsed .record-button-container { display: flex; justify-content: center; }
        .record-button { width: 40px; height: 40px; border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; transition: all 0.2s; padding: 0; }
        .record-button.ready { background: #4CAF50; color: white; }
        .record-button.recording { background: #f44336; color: white; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .record-button:hover { transform: scale(1.1); }
        .file-input-wrapper { margin-bottom: 10px; }
        input[type="file"] { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
        button { width: 100%; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; margin-top: 5px; }
        button:hover { background: #45a049; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .status { margin-top: 10px; padding: 8px; border-radius: 4px; font-size: 13px; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .location-info { margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 12px; color: #333; }
        .location-info div { margin: 3px 0; }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="controls" id="controlsPanel">
        <div class="controls-header" id="controlsHeader">
            <h3>GeoJSON Path Tracker</h3>
            <button class="collapse-toggle" id="collapseToggle">◀</button>
        </div>
        
        <div class="record-button-container">
            <button class="record-button ready" id="recordButtonCollapsed" title="Start Recording">⬤</button>
        </div>
        
        <div class="controls-content">
            <div class="file-input-wrapper">
                <input type="file" id="geojsonFile" accept=".geojson,.json" />
            </div>
            
            <div style="margin-bottom: 10px;">
                <label style="display: block; margin-bottom: 5px; font-size: 13px; color: #666;">Map Style:</label>
                <select id="basemapSelector" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                    <option value="streets">Streets</option>
                    <option value="dark" selected>Dark</option>
                    <option value="satellite">Satellite</option>
                    <option value="topo">Topographic</option>
                    <option value="osm">OpenStreetMap</option>
                </select>
            </div>
            
            <button id="toggleTracking">Enable Location</button>
            <button id="recordButton">Start Recording Path</button>
            <button id="centerUser">Center on My Location</button>
            <button id="fitPath">Fit to Path</button>
            <button id="downloadPath" style="background: #2196F3;">Download Recorded Path</button>
            
            <div id="status"></div>
            <div id="locationInfo" class="location-info" style="display: none;"></div>
            <div id="recordingInfo" class="location-info" style="display: none;"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
            crossorigin=""></script>
    <script>
        if (typeof L === 'undefined') {
            document.body.innerHTML = '<div style="padding: 20px; text-align: center;"><h2>Error</h2><p>Leaflet.js failed to load.</p></div>';
            throw new Error('Leaflet failed to load');
        }
        
        const map = L.map('map').setView([-27.4698, 153.0251], 13);

        const basemaps = {
            streets: L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap', maxZoom: 19 }),
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '© OpenStreetMap © CARTO', maxZoom: 19 }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri', maxZoom: 19 }),
            topo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { attribution: '© OpenTopoMap', maxZoom: 17 }),
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap', maxZoom: 19 })
        };

        let currentBasemap = basemaps.dark;
        currentBasemap.addTo(map);

        let userMarker = null;
        let userCircle = null;
        let pathLayer = null;
        let watchId = null;
        let isTracking = false;
        let currentPosition = null;
        let isRecording = false;
        let recordedPath = [];
        let recordedPathLayer = null;
        let maxSpeed = 0;
        let totalDistance = 0;

        function createUserIcon(heading = null) {
            const pointerSVG = heading !== null ? `
                <svg width="40" height="40" viewBox="0 0 40 40" style="position: absolute; top: -10px; left: -10px; transform: rotate(${heading}deg); transform-origin: 20px 20px;">
                    <path d="M 20 5 L 23 15 L 20 13 L 17 15 Z" fill="#4285F4" stroke="white" stroke-width="1.5" opacity="0.9"/>
                </svg>
            ` : '';
            return L.divIcon({
                className: 'user-location-marker',
                html: `${pointerSVG}<div style="background: #4285F4; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
        }

        const fileInput = document.getElementById('geojsonFile');
        const toggleButton = document.getElementById('toggleTracking');
        const centerButton = document.getElementById('centerUser');
        const fitPathButton = document.getElementById('fitPath');
        const basemapSelector = document.getElementById('basemapSelector');
        const recordButton = document.getElementById('recordButton');
        const recordButtonCollapsed = document.getElementById('recordButtonCollapsed');
        const downloadButton = document.getElementById('downloadPath');
        const controlsPanel = document.getElementById('controlsPanel');
        const controlsHeader = document.getElementById('controlsHeader');
        const collapseToggle = document.getElementById('collapseToggle');
        const statusDiv = document.getElementById('status');
        const locationInfoDiv = document.getElementById('locationInfo');
        const recordingInfoDiv = document.getElementById('recordingInfo');

        controlsHeader.addEventListener('click', function() {
            controlsPanel.classList.toggle('collapsed');
            collapseToggle.textContent = controlsPanel.classList.contains('collapsed') ? '▶' : '◀';
        });

        recordButtonCollapsed.addEventListener('click', function() { toggleRecording(); });
        recordButton.addEventListener('click', function() { toggleRecording(); });

        downloadButton.addEventListener('click', function() {
            if (recordedPath.length === 0) { showStatus('No path recorded yet', 'error'); return; }
            downloadRecordedPath();
        });

        basemapSelector.addEventListener('change', function(e) {
            map.removeLayer(currentBasemap);
            currentBasemap = basemaps[e.target.value];
            currentBasemap.addTo(map);
        });

        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const geojson = JSON.parse(event.target.result);
                    if (pathLayer) map.removeLayer(pathLayer);
                    pathLayer = L.geoJSON(geojson, {
                        style: { color: '#FF6B6B', weight: 4, opacity: 0.8 },
                        pointToLayer: function(feature, latlng) {
                            return L.circleMarker(latlng, { radius: 6, fillColor: '#FF6B6B', color: '#fff', weight: 2, opacity: 1, fillOpacity: 0.8 });
                        },
                        onEachFeature: function(feature, layer) {
                            if (feature.properties) {
                                let popupContent = '<div style="font-size: 13px;">';
                                for (let key in feature.properties) popupContent += `<b>${key}:</b> ${feature.properties[key]}<br>`;
                                popupContent += '</div>';
                                layer.bindPopup(popupContent);
                            }
                        }
                    }).addTo(map);
                    map.fitBounds(pathLayer.getBounds(), { padding: [50, 50] });
                    showStatus('GeoJSON loaded successfully!', 'success');
                } catch (error) {
                    showStatus('Error loading GeoJSON: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        });

        toggleButton.addEventListener('click', function() {
            if (!isTracking) requestLocationPermission();
            else stopTracking();
        });

        centerButton.addEventListener('click', function() {
            if (currentPosition) map.setView(currentPosition, 16);
            else showStatus('Location not available yet', 'error');
        });

        fitPathButton.addEventListener('click', function() {
            if (pathLayer) map.fitBounds(pathLayer.getBounds(), { padding: [50, 50] });
            else showStatus('No path loaded', 'error');
        });

        // FIXED: Simplified permission request
        function requestLocationPermission() {
            if (!navigator.geolocation) {
                showStatus('Geolocation not supported by your browser', 'error');
                return;
            }
            // Directly request tracking - let the browser handle the UI
            startTracking();
        }

        // FIXED: Increased timeout and error handling
        function startTracking() {
            showStatus('Requesting GPS access (wait for prompt)...', 'info');

            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
            }

            watchId = navigator.geolocation.watchPosition(
                updateUserLocation,
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 30000 // Increased to 30 seconds for Android
                }
            );

            isTracking = true;
            toggleButton.textContent = 'Stop Tracking';
            toggleButton.style.background = '#f44336';
        }

        function stopTracking() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            isTracking = false;
            toggleButton.textContent = 'Enable Location';
            toggleButton.style.background = '#4CAF50';
            showStatus('Tracking stopped', 'info');
            locationInfoDiv.style.display = 'none';
        }

        function updateUserLocation(position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const heading = position.coords.heading;
            const speed = position.coords.speed;
            const altitude = position.coords.altitude;
            const timestamp = position.timestamp;

            currentPosition = [lat, lng];

            if (isRecording) {
                const point = { lat, lng, timestamp, speed, heading, altitude, accuracy };
                recordedPath.push(point);
                if (speed !== null && speed > maxSpeed) maxSpeed = speed;
                if (recordedPath.length > 1) {
                    const prevPoint = recordedPath[recordedPath.length - 2];
                    totalDistance += calculateDistance(prevPoint.lat, prevPoint.lng, lat, lng);
                }
                updateRecordedPathLayer();
                updateRecordingInfo();
            }

            if (userMarker) {
                userMarker.setLatLng(currentPosition);
                userMarker.setIcon(createUserIcon(heading));
                userCircle.setLatLng(currentPosition);
                userCircle.setRadius(accuracy);
            } else {
                userMarker = L.marker(currentPosition, { icon: createUserIcon(heading) }).addTo(map);
                userCircle = L.circle(currentPosition, { radius: accuracy, color: '#4285F4', fillColor: '#4285F4', fillOpacity: 0.1, weight: 1 }).addTo(map);
            }

            locationInfoDiv.style.display = 'block';
            locationInfoDiv.innerHTML = `
                <div><b>Latitude:</b> ${lat.toFixed(6)}</div>
                <div><b>Longitude:</b> ${lng.toFixed(6)}</div>
                <div><b>Accuracy:</b> ±${accuracy.toFixed(1)}m</div>
                ${heading !== null ? `<div><b>Heading:</b> ${heading.toFixed(0)}° ${getCompassDirection(heading)}</div>` : ''}
                ${speed !== null ? `<div><b>Speed:</b> ${(speed * 3.6).toFixed(1)} km/h</div>` : ''}
            `;
            showStatus('Location tracking active', 'success');
        }

        function handleLocationError(error) {
            let message = 'Error getting location: ';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message = 'Permission denied. Check Browser settings AND make sure you are using HTTPS (not file://).';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message += 'Position unavailable';
                    break;
                case error.TIMEOUT:
                    message = 'GPS Timeout. Try moving outdoors for a better signal.';
                    break;
                default:
                    message += 'Unknown error';
            }
            showStatus(message, 'error');
            
            // Reset UI on fatal error
            isTracking = false;
            toggleButton.textContent = 'Enable Location';
            toggleButton.style.background = '#4CAF50';
        }

        function toggleRecording() {
            if (!isTracking) { showStatus('Please enable location tracking first', 'error'); return; }
            if (!isRecording) startRecording();
            else stopRecording();
        }

        function startRecording() {
            isRecording = true;
            recordedPath = [];
            maxSpeed = 0;
            totalDistance = 0;
            recordButton.textContent = 'Stop Recording';
            recordButton.style.background = '#f44336';
            recordButtonCollapsed.classList.remove('ready');
            recordButtonCollapsed.classList.add('recording');
            showStatus('Recording path started', 'success');
        }

        function stopRecording() {
            isRecording = false;
            recordButton.textContent = 'Start Recording Path';
            recordButton.style.background = '#4CAF50';
            recordButtonCollapsed.classList.remove('recording');
            recordButtonCollapsed.classList.add('ready');
            showStatus(`Recording stopped. ${recordedPath.length} points captured`, 'success');
        }

        function updateRecordedPathLayer() {
            if (recordedPathLayer) map.removeLayer(recordedPathLayer);
            if (recordedPath.length > 1) {
                const latlngs = recordedPath.map(p => [p.lat, p.lng]);
                recordedPathLayer = L.polyline(latlngs, { color: '#00FF00', weight: 4, opacity: 0.8 }).addTo(map);
            }
        }

        function updateRecordingInfo() {
            if (!isRecording || recordedPath.length === 0) { recordingInfoDiv.style.display = 'none'; return; }
            const duration = (recordedPath[recordedPath.length - 1].timestamp - recordedPath[0].timestamp) / 1000;
            const minutes = Math.floor(duration / 60);
            const seconds = Math.floor(duration % 60);
            recordingInfoDiv.style.display = 'block';
            recordingInfoDiv.innerHTML = `
                <div style="color: #f44336; font-weight: bold; margin-bottom: 5px;">● RECORDING</div>
                <div><b>Points:</b> ${recordedPath.length}</div>
                <div><b>Distance:</b> ${(totalDistance / 1000).toFixed(2)} km</div>
                <div><b>Speed:</b> ${(maxSpeed * 3.6).toFixed(1)} km/h</div>
                <div><b>Duration:</b> ${minutes}m ${seconds}s</div>
            `;
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function downloadRecordedPath() {
            const defaultName = `recorded-path-${new Date().toISOString().slice(0,10)}`;
            const filename = prompt('Enter a name for your path:', defaultName);
            if (filename === null || filename.trim() === '') return;
            let cleanFilename = filename.trim().replace(/[^a-z0-9_-]/gi, '-');
            if (!cleanFilename.toLowerCase().endsWith('.geojson')) cleanFilename += '.geojson';
            
            const geojson = {
                type: "FeatureCollection",
                properties: { name: filename.trim(), recordedAt: new Date(recordedPath[0].timestamp).toISOString(), distance: totalDistance },
                features: [{
                    type: "Feature",
                    properties: { name: filename.trim() },
                    geometry: { type: "LineString", coordinates: recordedPath.map(p => [p.lng, p.lat, p.altitude || 0]) }
                }]
            };

            const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = cleanFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showStatus(`Path saved as ${cleanFilename}`, 'success');
        }

        function getCompassDirection(heading) {
            if (heading === null) return '';
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            return directions[Math.round(heading / 45) % 8];
        }

        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
            statusDiv.style.display = 'block';
        }
    </script>
</body>
</html>